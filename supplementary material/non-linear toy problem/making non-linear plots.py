import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import gaussian_kde
import arviz as az
from matplotlib.lines import Line2D
from matplotlib.ticker import MaxNLocator
# Read the files generated by pymc Bayesian updating process
idata = az.from_netcdf('smc-abc IUQ 200000 unc included.nc')
idata_neglected= az.from_netcdf('NUTS IUQ 15000 unc neglected.nc')
idata_sigma= az.from_netcdf('NUTS IUQ 15000 unc as sigma.nc')
# Extract the posterior distributions from the pymc generated files
a1 = idata.posterior.a.data[0]
b1 = idata.posterior.b.data[0]
a2 = idata_neglected.posterior.a.data[0]
b2 = idata_neglected.posterior.b.data[0]
a3 = idata_sigma.posterior.a.data[0]
b3 = idata_sigma.posterior.b.data[0]
sigma3 = idata_sigma.posterior.sigma.data[0]
# Compute the KDEs
kdea1 = gaussian_kde(a1)
kdeb1 = gaussian_kde(b1)
kdea2 = gaussian_kde(a2)
kdeb2 = gaussian_kde(b2)
kdea3 = gaussian_kde(a3)
kdeb3 = gaussian_kde(b3)
kdesigma3 = gaussian_kde(sigma3)
# Generate a range of values for which we want to plot the KDE
x_valuesa1 = np.linspace(min(a1), max(a1), 1000)
x_valuesb1 = np.linspace(min(b1), max(b1), 1000)
x_valuesa2 = np.linspace(min(a2), max(a2), 1000)
x_valuesb2 = np.linspace(min(b2), max(b2), 1000)
x_valuesa3 = np.linspace(min(a3), max(a3), 1000)
x_valuesb3 = np.linspace(min(b3), max(b3), 1000)
x_valuessigma3 = np.linspace(min(sigma3), max(sigma3), 1000)
# Evaluate the KDE for these values
densitya1 = kdea1(x_valuesa1)
densityb1 = kdeb1(x_valuesb1)
densitya2 = kdea2(x_valuesa2)
densityb2 = kdeb2(x_valuesb2)
densitya3 = kdea3(x_valuesa3)
densityb3 = kdeb3(x_valuesb3)
densitysigma3 = kdesigma3(x_valuessigma3)
# Plot the KDEs
plt.plot(x_valuesa1, densitya1, label="UMIP uncertainties\nfully considered")
plt.plot(x_valuesa3, densitya3, label="UMIP uncertainties\nmodeled as part\nof $\sigma$", color="red")
plt.plot(x_valuesa2, densitya2, label="UMIP uncertainties\nfully neglected", color="#2ca02c")

plt.xlabel("Sample Value")
plt.ylabel("Relative density")
plt.title(f"Posterior of $a$")
ax = plt.gca()  # Get the current Axes instance
ax.xaxis.set_major_locator(MaxNLocator(nbins=5))
y_min, y_max = plt.ylim()  # Get the current y-axis limits to use as reference
line_bottom = 0  # Start from the bottom of the plot (or adjust as needed)
line_top = y_max # End the line at the top of the plot
plt.plot([18, 18], [line_bottom, line_top], color='black', linestyle='-', linewidth=0.9)
handles, labels = plt.gca().get_legend_handles_labels()
handles.append(Line2D([0], [0], color='black', lw=0.9))
labels.append('True value')
plt.legend(handles=handles, labels=labels)
plt.savefig("non_linear_a.png", dpi=300, facecolor='white')
plt.show()

plt.plot(x_valuesb1, densityb1, label="UMIP uncertainties\nfully considered")
plt.plot(x_valuesb3, densityb3, label="UMIP uncertainties\nmodeled as part\nof $\sigma$", color="red")
plt.plot(x_valuesb2, densityb2, label="UMIP uncertainties\nfully neglected", color="#2ca02c")
plt.xlabel("Sample Value")
plt.ylabel("Relative density")
plt.title(f"Posterior of $b$")
y_min, y_max = plt.ylim()  # Get the current y-axis limits to use as reference
line_bottom = 0  # Start from the bottom of the plot (or adjust as needed)
line_top = y_max  # End the line at the top of the plot
plt.plot([11, 11], [line_bottom, line_top], color='black', linestyle='-', linewidth=0.9)
handles, labels = plt.gca().get_legend_handles_labels()
handles.append(Line2D([0], [0], color='black', lw=0.9))
labels.append('True value')
plt.legend(handles=handles, labels=labels)

plt.savefig("non_linear_b.png", dpi=300, facecolor='white')
plt.show()

plt.plot(x_valuessigma3, densitysigma3, label=r'$\sigma$', color="red")
plt.xlabel("Sample Value")
plt.ylabel("Relative density")
plt.title(f"Posterior of $\sigma$")
plt.legend()
plt.savefig("non_linear_sigma.png", dpi=300)
plt.show()
# Find the index of the maximum density
max_density_index = np.argmax(densitysigma3)
# Find the x value corresponding to the maximum density, which is the mode of the distribution
mode = x_valuessigma3[max_density_index]

print("Mode of the distribution:", mode)

